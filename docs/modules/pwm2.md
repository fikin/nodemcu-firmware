# PWM Module
| Since  | Origin / Contributor  | Maintainer  | Source  |
| :----- | :-------------------- | :---------- | :------ |
| 2019-02-12 | [fikin](https://github.com/fikin) | [fikin](https://github.com/fikin) | [pwm2.c](../../../app/modules/pwm2.c)|

Module to generate PWM impulses to any of the GPIO pins. 

PWM is being generated by software using soft-interrupt timer FRC1. This timer is used by other modules like ws2812 and pwm, but only one of them can use it at given time.

Supported frequencies are roughly from 250kHZ to 19sec with varying pulse period. See [understanding frequencies](#understand-frequencies) for more.

Supported are also frequency fractions even for integer-only firmware builds.

Supported are all of the GPIO pins except pin 0. 

One can generate different PWM signals to any of them at the same time. See [working with multiple frequencies](#working-with-multiple-frequencies) for more.

This module supportes CPU80MHz as well as CPU160MHz.

Typical usage is as following:
```lua
pwm2.setup_pin_hz(4,1,2,1) -- pin 4, PWM freq of 1HZ, pulse period of 2 steps, initial duty 1 resolution step 
pwm2.start() -- starts pwm, internal led will blink with 0.5sec interval
...
pwm2.set_duty(4, 2) -- led full on
...
pwm2.stop() -- PWM stopped, gpio pin released, timer1 released
```

## Understand frequencies

All frequencines and periods internally are expressed as CPU ticks using following formula: cpuTicksPerSecond / (frequencyHz * period). For example, 1kHz with 1000 period for CPU80MHz results in 80 CPU ticks per period i.e. 1uS period.

In order to allow for better tunning, I've added an optional frequencyDivisor argument when setting up pins. With it one can express the frequency as division between two values : frequency / divisor. For example to model 100,1Hz frequency one has to specify frequency of 1001 and divisor 10.

## Frequency precision

ESP's TIMER1 FRC1 is operating at fixed, own frequency of 5MHz. Therefore the precision of individual interrupt is 200ns. But OS interrupt handler itself has internal overhead, which for auto-loaded interrupts is about 80CPUTicks. With PWM2 own interrupt handler overhead of 162CPUTicks + 12CPUTicks per used pin, one can expect effective interrupt frequency from 242kHz for 1pin to 175kHz for 12 pins for CPU80MHz. For CPU160MHz these figures almost double but not exactly.

Because TIMER1 frequency is 1/16 of CPU frequency, frequncy precision is lost when converting from CPU to TIMER ticks. One can inspect exact values via [pwm.print_setup()](#print_setup). Value of interruptTimerCPUTicks represents desired interrupt period in CPUTicks. And interruptTimerTicks represents actually used interrupt period as TIMER1 ticks (1/16 of CPU).

## Working with multiple frequencies

When working with multiple pins, this module tries to find the greatest common interrupt frequency and use it for PWM generation.

When using one frequency for many pins, tunning that with one pin is enough to ensure precision.

But when using different frequencies, one has to pay close attention at their greates common divisor. For example, mixing 100kHz with period 2 and 0.5Hz with period 2 results in underlying interrupt period of 800CPU ticks. But changing to 100kHz+1 will easily result divisor of 1. This is clearly non-working combination. For the moment best would be to [pwm.print_setup()](#print_setup) and observe how interruptTimerCPUTicks and interruptTimerTicks change with given input.

## Troubleshooting watchdog timeouts

Watchdog interrupt typically will occur if choosen frequency (and period) is too big. For CPU80MHz I guess threshold is around 120kHz with period of 2 and single pin, given not much other load on the system.

Another reason for watchdog interrupt to occur is due to mixing otherwise not very compatible frequencies when multiple pins are used. Desired frequencies once are converted to CPU ticks, then their greatest common divisor is found, then converted to TIMER1 ticks. Any of these steps imposes risk of incomatibility. For example frequency of 120kHz with period 2 results in 333CPU ticks period, which if combined with even-resulting frequency like 1Hz with period of 2, will lead to common divisor of 1, which is clearly impractical.

Both cases best are anlyzed using [pwm.print_setup()](#print_setup) wathcing for interruptTimerCPUTicks and interruptTimerTicks. For interruptTimerCPUTicks and CPU80MHz anything below 400 for 12 pins or 250 for 1 pin would be cause for special attention. For CPU160MHz these values can drop almost double.

## pwm2.setup_pin_hz()
Assigns PWM frequency expressed as Hz to given pin.
This method is suitable for setting up frequencies in the range of >=1Hz.

#### Syntax
`pwm2.setup_pin_hz(pin,frequencyAsHz,pulsePeriod,initialDuty [,frequencyDivisor])`

#### Parameters
`pin` 1-12
`frequencyAsHz` desired frequency in Hz, for example 1000 for 1KHz
`pulsePeriod` discreet steps in single PWM pulse, for example 100
`initialDuty` initial duty in pulse period steps i.e. 50 for 50% pulse of 100 resolution
`frequencyDivisor` an integer to divide product of frequency and pulsePeriod. Used to form frequency fractions. By default not required.

#### Returns
`nil`

#### See also
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.start()](#start)
[pwm.release_pin()](#release_pin)
[understanding frequencies](#understand-frequencies)
[working with multiple frequencies](#working-with-multiple-frequencies)
[pwm.print_setup()](#print_setup)

## pwm2.setup_pin_sec()
Assigns PWM frequency expressed as one impulse per second(s) to given pin.
This method is suitable for setting up frequencies in the range of 0<1Hz but expressed as seconds instead.

#### Syntax
`pwm2.setup_pin_sec(pin,frequencyAsSec,pulsePeriod,initialDuty [,frequencyDivisor])`

#### Parameters
`pin` 1-12
`frequencyAsSec` desired frequency as one impulse for given seconds, for example 2 means PWM with impulse long 2 seconds.
`pulsePeriod` discreet steps in single PWM pulse, for example 100
`initialDuty` initial duty in pulse period steps i.e. 50 for 50% pulse of 100 resolution
`frequencyDivisor` an integer to divide product of frequency and pulsePeriod. Used to form frequency fractions. By default not required.

#### Returns
`nil`

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.start()](#start)
[pwm.release_pin()](#release_pin)
[understanding frequencies](#understand-frequencies)
[working with multiple frequencies](#working-with-multiple-frequencies)
[pwm.print_setup()](#print_setup)

## pwm.start()
Starts PWM for all setup pins.
At this moment GPIO pins are marked as output and TIMER1 is being reserved for this module.
If the TIMER1 is already reserved by another module this method reports error.

#### Syntax
`pwm.start()`

#### Parameters
`nil`

#### Returns
`nil`

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.set_duty()](#set_duty)
[pwm.stop()](#stop)

## pwm.stop()
Stops PWM for all pins. All GPIO pins and TIMER1 are being released.
One to resume PWM with previous pin settings by calling [pwm.start()](#start) right after stop.

#### Syntax
`pwm.stop()`

#### Parameters
`nil`

#### Returns
`nil`

#### See also
[pwm.start()](#start)
[pwm.release_pin()](#release_pin)

## pwm.set_duty()
Sets duty cycle for one or more a pins. This method takes immediate effect to ongoing PWM generation.

#### Syntax
`pwm.set_duty(pin, duty [,pin,duty]*)`

#### Parameters
- `pin` 1~12, IO index
- `duty` 0~period, pwm duty cycle 

#### Returns
`nil`

#### See also
[pwm.stop()](#stop)

## pwm.release_pin()
Releases given pin from previously done setup. This method is applicable when PWM is stopped and given pin is not needed anymore.

#### Syntax
`pwm.release_pin(pin)`

#### Parameters
`pin` 1~12, IO index

#### Returns
`nil`

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.setup_pin_sec()](#setup_pin_sec)
[pwm.stop()](#stop)

## pwm.print_setup()
Prints internal data structures. This method is usefull for people troubleshooting frequency side effects.

#### Syntax
`pwm.print_setup()`

#### Parameters
`nil`

#### Returns
`nil`

#### See also
[pwm.setup_pin_hz()](#setup_pin_hz)
[pwm.setup_pin_sec()](#setup_pin_sec)
